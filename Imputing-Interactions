###########################################################################
# Title: Imputing interaction variables: performance of various approaches
# Author: Matthew J. Smith, Edmund Njeru Njagi
# Date: 6th March 2022
###########################################################################

# Set working directory
setwd("N:/ICON_all/Users/Matthew Smith/Research Fellow in Statistics/Methods")

# Set the seed
seed <- 1234

# Define the function 
sim.dt <- function(n=10000, seed=seed, ydiagmin=2005, ydiagmax=2010,
                   probtreat=0.3, probfem=0.5, meanage=70, sdage=10, probdep=1.2, probstage=0.1, probcmb=0.35, probfrailty=0.2, probroute=0.2,  
                   treatef=0.7, sexef=1.1, ageef=1.4, 
                   dep2ef=1, dep3ef=1, dep4ef=1, dep5ef=1, stageef=1, cmbef=1, frailef=1, routeef=1, depef=1, IntStageCmbef=1 
                   #, ind.var = 'treat + sex + agediag'
) {
  
  # Set the seed
  set.seed(seed)
  
  # Simulate the variables
  treat <- rbinom(n, 1, prob = probtreat) # Treatment: 0 = control, 1 = treated
  sex <- rbinom(n, size = 1, prob = probfem) #Sex: 0 = male, 1 = female
  agediag <- rnorm(n, meanage, sdage); agediag <- (agediag - mean(agediag))/10 
  dep <- rbeta(n, 1, probdep) # Deprivation: binomial distribution with 'b' as 1.2 by default
  depcat <- ifelse(dep<0.2,1,
                   ifelse(dep<0.4,2,
                          ifelse(dep<0.6,3,
                                 ifelse(dep<.8,4,
                                        ifelse(dep>= .8, 5, 0))))); 
  dep2 <- ifelse(depcat==2,1,0)
  dep3 <- ifelse(depcat==3,1,0)
  dep4 <- ifelse(depcat==4,1,0)
  dep5 <- ifelse(depcat==5,1,0)
  stage <- rbinom(n, size = 1, prob = probstage) #Stage: 0 = (I-III), 1 = IV
  cmb <- rbinom(n, size = 1, prob = probcmb) # Comorbidity: 0=no, 1=yes
  frailty <- rbinom(n, size = 1, prob = probfrailty) # Frailty: 0 = not, 1 = frail
  route <- rbinom(n, 1, prob = probroute) # Route: 0 = non-emergency, 1 = emergency
  year <- runif(n, min = ydiagmin, max = ydiagmax) # Year of diagnosis
  IntStageCmb <- stage*cmb
  
  # Specify parameters for the outcome model
  beta1 <-  log(treatef) # Treatment
  beta2 <-  log(sexef) # Sex
  beta3 <-  log(ageef) # Age
  beta4 <-  log(dep2ef) # Deprivation 2
  beta5 <-  log(dep3ef) # Deprivation 3
  beta6 <-  log(dep4ef) # Deprivation 4
  beta7 <-  log(dep5ef) # Deprivation 5
  beta8 <-  log(stageef) # Stage
  beta9 <-  log(cmbef) # Comorbidity
  beta10 <- log(frailef) # Frailty
  beta11 <- log(routeef) # Route
  beta12 <- log(depef) # Deprivation (continuous)
  beta13 <- log(IntStageCmbef)
  
  # Create the design matrix
  coef.vec <- c(beta1,beta2,beta3,beta4,beta5,beta6,beta7,beta8,beta9,beta10,beta11,beta12,beta13)
  design.mat <- cbind(treat,sex,agediag,dep2,dep3,dep4,dep5,stage,cmb,frailty,route,dep,IntStageCmb)
  
  z <- -3 + (design.mat %*% coef.vec)
  
  prdeath <- 1 / (1 + exp(-z))         # pass through an inv-logit function
  death  <- rbinom(n,1,prdeath)        # Indicator of death within 30 days
  
  # Put the variables into a data frame
  df <- data.frame(death, prdeath, treat, sex, agediag, dep2, dep3, dep4, dep5, stage, cmb, frailty, route, dep, IntStageCmb, year)
  return(df)
}


# Run the function
data <- sim.dt(n = 100000, seed = seed,
               probtreat = 0.3, probfem = 0.5,
               treatef = 0.7, ageef = 1.4, sexef = 0.9, depef = 1.3, cmbef = 1.4, stageef = 1.8, IntStageCmbef = 1.3)


########################################  
# Simulate missing data
########################################  

# First define some objects
n <- length(data$agediag)
p.stage  <- c(40)
#z.stage  <- seq( -7.75,  -7.74, 0.01)
z.stage <- seq(-5.0, -0.0, 0.01)

#n.sim <- c(1,2,3,4,5,6,8,9,10,11,13,14,15,16,17,18,19,21,23,24,26,28,31,32,33,34,35,36,37,38,39,40,
#            41,44,45,47,48,49,50,51,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,71,72,73,74,75,
#            76,77,78,79,80,82,83,84,85,87,88,89,91,92,93,94,95,96,99,100,101,102,103,105,107,108,109,110,
#            111,112,114,115,116,117,118,119,120,121)          # n.sim   <- seq(121,130,1)
n.sim <- seq(1,100,1)
#n.sim <- 1:2
#  n.sim3 <- c(7,12,20,22,25,27,29,30,42,43,46,52,70,81,86,90,97,98,104,106,113)

# Outcome-dependent missing at random for Stage
stage.omar <- function(n, betas, seed=k) {
  data$p.miss <- (exp(betas))/(1+exp(betas));     summary(data$p.miss)
  set.seed(k)
  data$i.miss <- rbinom(1:n,1, prob=data$p.miss);    prop.table(table(data$i.miss))
  miss.prop <- (plyr::round_any(mean(data$i.miss), accuracy=0.01, f = round))*100; miss.prop
  col_name <- paste0('stage.omar', '.', miss.prop, '.', k)
  stage2 <- data.frame(ifelse(data$i.miss==1, NA, data$stage))
  colnames(stage2) <- col_name
  data <- cbind(data,stage2)
  return(data)
}
count <- 0
start_time <- Sys.time()
for (k in n.sim) {
  count <- count + 1
  for (j in z.stage) {
    betas <- j + 1.0*(data$treat) + 1.0*(data$agediag) + 1.0*(data$sex) + 1.0*(data$dep) + 1.0*(data$cmb) + 10.0*(data$death)
    data$p.miss <- (exp(betas))/(1+exp(betas));     summary(data$p.miss)
    set.seed(k)
    data$i.miss <- rbinom(1:n,1, prob=data$p.miss);    prop.table(table(data$i.miss))
    miss.prop <- (plyr::round_any(mean(data$i.miss), accuracy=0.01, f = round))*100; miss.prop
    for (i in p.stage) {
      if (miss.prop==(i) ) {  
        data <- stage.omar(n, betas, seed=k)
      }
    }
    data <- data[, !duplicated(colnames(data))]
  }
  print(paste0("Missing data for simulation ", count, " done"))
}
end_time <- Sys.time()
end_time - start_time

# Check the distribution and number of missing values in the partially observed stage variables
for (i in n.sim) {
  print(summary(data[[paste0("stage.omar.40.", i)]]))
}

# Duplicate the data
data2 <- data  


##################################### 
# Fully observed results
#####################################    

# Check the results of the fully observed data
model1 <- glm( death ~ treat + agediag + sex + dep + cmb + stage + IntStageCmb,
               data = data2, family = "binomial"); summary(model1); exp(model1$coefficients[-1])

model1.1 <- glm( death ~ treat + agediag + sex + dep + cmb + stage + cmb*stage,
                 data = data2, family = "binomial"); summary(model1.1); exp(model1.1$coefficients[-1])


##################################### 
# Complete case analysis
#####################################  

# Check the results of the fully observed data
model2 <- glm( death ~ treat + agediag + sex + dep + cmb + stage.omar.40.2 + IntStageCmb,
               data = data2, family = "binomial"); summary(model2); exp(model2$coefficients[-1])

model2.1 <- glm( death ~ treat + agediag + sex + dep + cmb + stage.omar.40.2 + cmb*stage.omar.40.2,
                 data = data2, family = "binomial"); summary(model2.1); exp(model2.1$coefficients[-1])

# Create a list to hold the results of each model
cca.models <- list()

# Loop through the models
count <- 0                                                      # Set the counter

for (i in n.sim) {                                           
  count <- count + 1
  data2$stage.var  <- data2[[paste0("stage.omar.40.", i)]]      # Stage variable
  data2$IntStageCmb <- data2$cmb * data2$stage.var           # Recode the interaction between stage and comorbidity (since stage is missing)
  
  invisible(capture.output(suppressWarnings( 
    cca.i <- glm( death ~ treat + agediag + sex + dep + cmb + stage.var + cmb*stage.var,
                  data = data2, family = "binomial")
  )))
  cca.models[[i]] <- cca.i
  print(paste0("Model ", count, " done"))
}

# Summarise the coefficients of the simulations of the complete case analysis
for (i in n.sim) {
  print(exp(cca.models[[i]]$coefficients))
}

# Average of the coefficients for the Interaction across the simulations
int.coef <- 0
cca.int.coef <- data.frame(int.coef)
for (i in n.sim) {
  cca.int.coef[i,] <- cca.models[[i]]$coefficients[8]
}

cca.int.coef <- cca.int.coef[complete.cases(cca.int.coef),]
exp(mean(cca.int.coef))             # Average hazard ratio across the simulations: 1.08
exp(model1.1$coefficients[-1])


####################
# Passive imputation
####################

# Install necessary packages
library(mice)
library(tidyr)
library(mitools)

# Specify number of imputations
m <- 20
maxit <- 1

# Define the initial value for the count
count <- 0

# Create a list to store the imputations for each simulation
pass.sim <- list()

# Loop through the simulations  
for (i in n.sim) {
  # Set the counter
  count <- count + 1
  
  # Obtain the data
  data2 <- data
  
  # Redefine the variables as factors
  data2$stage.var  <- as.factor(data2[[paste0("stage.omar.40.", i)]])      # Stage variable
  
  # Specify the variables to be used in the imputation
  data2 <- data2[,c('death','treat','agediag','sex','dep','cmb','stage.var')]
  
  # Perform passive imputation
  pass.imp <- mice(data2, meth = c('','','','','','','logreg'), m=m, maxit = maxit, seed = 1234)  # Perform passive imputation
  
  # Save the imputations of this simulation
  pass.sim[[i]] <- pass.imp
  
  # State the completion of the simulation
  print(paste0("Simulation ", count, " done"))
}


# For each imputed data set, create the interaction variable based on stage*comorbidity
pass.sim.data <- list()
pass.imp.data <- list()
for (i in n.sim) {
  for (j in 1:m) {
    pass.imp.data[[j]] <- complete(pass.sim[[i]], j)
    
    pass.imp.data[[j]]$stage.var <- as.numeric(pass.imp.data[[j]]$stage.var)
    
    pass.imp.data[[j]]$stage.var <- pass.imp.data[[j]]$stage.var - 1
    
    pass.imp.data[[j]]$IntStageCmb <- pass.imp.data[[j]]$cmb * as.numeric(pass.imp.data[[j]]$stage.var)
    
    print(head(pass.imp.data[[j]][is.na(data2$stage.var), ], 10))
  }
  pass.sim.data[[i]] <- pass.imp.data
}

# Check that it has worked ... the syntax of "[[1]][[2]]" means 1st simulation and 2nd imputed data set
summary(pass.sim.data[[1]][[1]][is.na(data2$stage.var), ])
summary(pass.sim.data[[1]][[2]][is.na(data2$stage.var), ])

summary(pass.sim.data[[1]][[2]][is.na(data2$stage.var), ])
summary(pass.sim.data[[2]][[2]][is.na(data2$stage.var), ])

head(pass.sim.data[[1]][[2]][is.na(data2$stage.var), ], 10)
head(pass.sim.data[[2]][[1]][is.na(data2$stage.var), ], 10)

# For each simulation, obtain the coefficients for each of the imputed data sets
pass.sim.fit <- list()
pass.imp.fit <- list()
for (i in n.sim) {
  for (j in 1:m) {  
    invisible(capture.output(pass.imp.fit.j <- glm(death ~ treat + agediag + sex + dep + cmb + stage.var + IntStageCmb,
                                                   data = pass.sim.data[[i]][[j]], family = "binomial") 
    ))
    pass.imp.fit[[j]] <- pass.imp.fit.j
    print(paste0("Model ", j, " done"))
  }  
  pass.sim.fit[[i]] <- pass.imp.fit
  print(paste0("Simulation ", i, " done"))
}

# Return the coefficients from the substantive model that was applied to each imputed data set
for (i in n.sim) {
  for (j in 1:m) {
    print(exp(pass.sim.fit[[i]][[j]]$coefficients))
  }  
}

# Within each simulation, combine the estimates
pass.sim.coef <- list()
pass.sim.var <- list()
pass.sim.est <- list()

for (i in n.sim) {
  pass.sim.coef[[i]] <- MIextract(pass.sim.fit[[i]], fun = coef);  pass.sim.coef[[i]]
  pass.sim.var[[i]] <- MIextract(pass.sim.fit[[i]], fun = function(x) diag(vcov(x)));  pass.sim.var[[i]]
  
  pass.sim.est[[i]] <- MIcombine(pass.sim.coef[[i]], pass.sim.var[[i]])
  summary(pass.sim.est[[i]])
}


# Save the coefficients from each of the simulations
pass.all.coef <- data.frame(matrix(nrow=1,ncol=8))
for (i in n.sim) {
  pass.all.coef[i,] <- pass.sim.est[[i]]$coefficients
}

# Average of the coefficients across the simulations
pass.mean.coef <-  data.frame(matrix(nrow=1,ncol=8))
pass.mean.coef[1] <- mean(pass.all.coef$X1)
pass.mean.coef[2] <- mean(pass.all.coef$X2)
pass.mean.coef[3] <- mean(pass.all.coef$X3)
pass.mean.coef[4] <- mean(pass.all.coef$X4)
pass.mean.coef[5] <- mean(pass.all.coef$X5)
pass.mean.coef[6] <- mean(pass.all.coef$X6)
pass.mean.coef[7] <- mean(pass.all.coef$X7)
pass.mean.coef[8] <- mean(pass.all.coef$X8)
colnames(pass.mean.coef) <- c('Intercept','Treat','Agediag','Sex','Dep','Cmb','Stage','Int')
exp(pass.mean.coef)
#pass.int.coef <- pass.int.coef[complete.cases(pass.int.coef),]
#exp(mean(pass.int.coef))             # Average hazard ratio across the simulations: 1.08
#pass.t.test <- t.test(pass.int.coef)
#exp(pass.t.test$conf.int)


# Summarise the results so far
exp(model1$coefficients)
exp(model2$coefficients)
exp(pass.mean.coef)


#######################  
# Just another variable
#######################

# Install necessary packages
library(mice)
library(tidyr)

# Define the initial value for the count
count <- 0

# Create a list to store the imputations for each simulation
jav.sim <- list()

# Loop through the simulations  
for (i in n.sim) {
  # Set the counter
  count <- count + 1
  
  # Obtain the data
  data2 <- data
  
  # Rename the variables of interest
  data2$stage.var  <- data2[[paste0("stage.omar.40.", i)]]      # Stage variable
  
  # Recode the interaction variable (because it must be missing when stage is missing)
  data2$IntStageCmb <- data2$cmb * data2$stage.var
  
  # Convert to factor variables
  data2$stage.var <- as.factor(data2$stage.var)
  data2$IntStageCmb <- as.factor(data2$IntStageCmb) 
  
  # Specify the variables to be used in the imputation
  data2 <- data2[,c('death','treat','agediag','sex','dep','cmb','stage.var','IntStageCmb')]
  
  # Perform passive imputation
  jav.imp <- mice(data2, meth = c('','','','','','','logreg','logreg'), m=m, maxit = maxit, seed = 1234)  # Perform passive imputation
  
  # Save the imputations of this simulation
  jav.sim[[i]] <- jav.imp
  
  # State the completion of the simulation
  print(paste0("Simulation ", count, " done"))
}


# Extract the imputed data sets
jav.sim.data <- list()
jav.imp.data <- list()
for (i in n.sim) {
  for (j in 1:m) {
    jav.imp.data[[j]] <- complete(jav.sim[[i]],j)
    
    jav.imp.data[[j]]$stage.var   <- as.numeric(jav.imp.data[[j]]$stage.var)
    jav.imp.data[[j]]$IntStageCmb <- as.numeric(jav.imp.data[[j]]$IntStageCmb)
    
    jav.imp.data[[j]]$stage.var   <- jav.imp.data[[j]]$stage.var - 1
    jav.imp.data[[j]]$IntStageCmb <- jav.imp.data[[j]]$IntStageCmb - 1
    
    #print(head(jav.imp.data[[j]][is.na(data$stage.var), ], 10))
  }
  jav.sim.data[[i]] <- jav.imp.data
} 

# Print the first few rows from each imputed data sets
for (i in 1:m) {
  print(head(complete(jav.imp,i)[is.na(data2$stage.var), ], 10))
}

# Obtain coefficients for each of the data sets
jav.sim.fit <- list()
jav.imp.fit <- list()
for (i in n.sim) {
  for (j in 1:m) {  
    invisible(capture.output(jav.imp.fit.j <- glm(death ~ treat + agediag + sex + dep + cmb + stage.var + IntStageCmb,
                                                  data = jav.sim.data[[i]][[j]], family = "binomial")
    ))
    jav.imp.fit[[j]] <- jav.imp.fit.j
    print(paste0("Model ", j, " done"))
  }
  jav.sim.fit[[i]] <- jav.imp.fit
  print(paste0("Simulation ", i, " done"))
}


# Return the coefficients from the substantive model that was applied to each imputed data set
for (i in n.sim) {
  for (j in 1:m) {
    print(exp(jav.sim.fit[[i]][[j]]$coefficients))
  }  
}

# Within each simulation, combine the estimates
jav.sim.coef <- list()
jav.sim.var <- list()
jav.sim.est <- list()

for (i in n.sim) {
  jav.sim.coef[[i]] <- MIextract(jav.sim.fit[[i]], fun = coef);  jav.sim.coef[[i]]
  jav.sim.var[[i]]  <- MIextract(jav.sim.fit[[i]], fun = function(x) diag(vcov(x)));  jav.sim.var[[i]]
  
  jav.sim.est[[i]] <- MIcombine(jav.sim.coef[[i]], jav.sim.var[[i]])
  summary(jav.sim.est[[i]])
}


# Save the coefficients from each of the simulations
jav.all.coef <- data.frame(matrix(nrow=1,ncol=8))
for (i in n.sim) {
  jav.all.coef[i,] <- jav.sim.est[[i]]$coefficients
}

# Average of the coefficients across the simulations
jav.mean.coef <-  data.frame(matrix(nrow=1,ncol=8))
jav.mean.coef[1] <- mean(jav.all.coef$X1)
jav.mean.coef[2] <- mean(jav.all.coef$X2)
jav.mean.coef[3] <- mean(jav.all.coef$X3)
jav.mean.coef[4] <- mean(jav.all.coef$X4)
jav.mean.coef[5] <- mean(jav.all.coef$X5)
jav.mean.coef[6] <- mean(jav.all.coef$X6)
jav.mean.coef[7] <- mean(jav.all.coef$X7)
jav.mean.coef[8] <- mean(jav.all.coef$X8)
colnames(jav.mean.coef) <- c('Intercept','Treat','Agediag','Sex','Dep','Cmb','Stage','Int')
exp(jav.mean.coef)


# Summarise the results so far
exp(model1$coefficients) 
exp(model2$coefficients) 
exp(pass.mean.coef)
exp(jav.mean.coef)


########################
# Stratify-impute-append
########################

# Create a list to store the imputations for each simulation
sia.sim.cmb0 <- list()
sia.sim.cmb1 <- list()

# Define the initial values for the loop
count <- 0 # count number of simulations

# Loop through the simulations  
for (i in n.sim) {
  # Set the counter
  count <- count + 1
  
  # Obtain the data
  data2 <- data
  
  # Redefine the variables as factors
  data2$stage.var  <- as.factor(data2[[paste0("stage.omar.40.", i)]])      # Stage variable
  
  
  # Specify the variables to be used in the imputation
  data2 <- data2[,c('death','treat','agediag','sex','dep','cmb','stage.var')]
  
  # Stratify the data by levels of comorbidity
  # For those without comorbidity
  data2.cmb0 <- data2[data2$cmb == 0,]
  data2.cmb0 <- subset(data2.cmb0, select = -(cmb))
  # For those with comorbidity
  data2.cmb1 <- data2[data2$cmb == 1,]
  data2.cmb1 <- subset(data2.cmb1, select = -(cmb))  
  
  # Separately for each strata of comorbidity, impute the partially observed variables  
  # For those without comorbidity
  # Impute
  sia.imp.cmb0 <- mice(data2.cmb0, meth = c('','','','','','logreg'), 
                       m=m, maxit = maxit, seed = 1234)  # Perform passive imputation    
  # Save the imputations of this simulation
  sia.sim.cmb0[[i]] <- sia.imp.cmb0
  
  # State the completion of the imputation for cmb0
  print(paste0("Imputation for Cmb0 done"))
  
  # For those without comorbidity
  #Impute
  sia.imp.cmb1 <- mice(data2.cmb1, meth = c('','','','','','logreg'), 
                       m=m, maxit = maxit, seed = 1234)  # Perform passive imputation    
  # Save the imputations of this simulation
  sia.sim.cmb1[[i]] <- sia.imp.cmb1
  
  # State the completion of the imputation for cmb1
  print(paste0("Imputation for Cmb1 done"))
  
  # State the completion of this simulation
  print(paste0("Simulation ", count, " done"))
}


# For each imputed data set, create the interaction variable based on stage*comorbidity
sia.sim.cmb0.data <- list()
sia.imp.cmb0.data <- list()
sia.sim.cmb1.data <- list()
sia.imp.cmb1.data <- list()
for (i in n.sim) {
  for (j in 1:m) {
    # For those without comorbidity
    sia.imp.cmb0.data[[j]] <- complete(sia.sim.cmb0[[i]], j)
    
    sia.imp.cmb0.data[[j]]$cmb <- 0
    
    sia.imp.cmb0.data[[j]]$stage.var <- as.numeric(sia.imp.cmb0.data[[j]]$stage.var)
    
    sia.imp.cmb0.data[[j]]$stage.var <- sia.imp.cmb0.data[[j]]$stage.var - 1
    
    sia.imp.cmb0.data[[j]]$IntStageCmb <- sia.imp.cmb0.data[[j]]$cmb * sia.imp.cmb0.data[[j]]$stage.var
    
    # For those with comorbidity
    sia.imp.cmb1.data[[j]] <- complete(sia.sim.cmb1[[i]], j)
    
    sia.imp.cmb1.data[[j]]$cmb <- 1
    
    sia.imp.cmb1.data[[j]]$stage.var <- as.numeric(sia.imp.cmb1.data[[j]]$stage.var)
    
    sia.imp.cmb1.data[[j]]$stage.var <- sia.imp.cmb1.data[[j]]$stage.var - 1
    
    sia.imp.cmb1.data[[j]]$IntStageCmb <- sia.imp.cmb1.data[[j]]$cmb * sia.imp.cmb1.data[[j]]$stage.var
  }
  sia.sim.cmb0.data[[i]] <- sia.imp.cmb0.data
  sia.sim.cmb1.data[[i]] <- sia.imp.cmb1.data
}


# Append the imputed data sets for the two strata (giving K imputed data sets)
sia.sim.cmb.data <- list()
sia.sim.cmb.data.merge <- list()
for (i in n.sim) {
  for (j in 1:m) {
    sia.sim.cmb.data.merge[[j]] <- rbind(sia.sim.cmb0.data[[i]][[j]], sia.sim.cmb1.data[[i]][[j]])
  }
  sia.sim.cmb.data[[i]] <- sia.sim.cmb.data.merge
}



# Obtain coefficients for each of the data sets
sia.imp.fit <- list()
sia.sim.fit <- list()
for (i in n.sim) {
  for (j in 1:m) {  
    invisible(capture.output(sia.imp.fit.j <- glm(death ~ treat + agediag + sex + dep + cmb + stage.var + IntStageCmb,
                                                  data = sia.sim.cmb.data[[i]][[j]], family = "binomial") #; summary(sia.imp.fit.i)
    ))
    sia.imp.fit[[j]] <- sia.imp.fit.j
    print(paste0("Model ", j, " done"))
  }    
  sia.sim.fit[[i]] <- sia.imp.fit
  print(paste0("Simulation ", i, " done"))
}


# Return the coefficients from the substantive model that was applied to each imputed data set
for (i in n.sim) {
  for (j in 1:m) {
    print(sia.sim.fit[[i]][[j]]$coefficients)
  }
}


# Within each simulation, combine the estimates
sia.sim.coef <- list()
sia.sim.var <- list()
sia.sim.est <- list()

for (i in n.sim) {
  sia.sim.coef[[i]] <- MIextract(sia.sim.fit[[i]], fun = coef);  sia.sim.coef[[i]]
  sia.sim.var[[i]]  <- MIextract(sia.sim.fit[[i]], fun = function(x) diag(vcov(x)));  sia.sim.var[[i]]
  
  sia.sim.est[[i]] <- MIcombine(sia.sim.coef[[i]], sia.sim.var[[i]])
  print(paste0("Simulation ", i, " done"))
}

for (i in n.sim) {
  print(exp(sia.sim.est[[i]]$coefficients))
}


# Save the coefficients from each of the simulations
sia.all.coef <- data.frame(matrix(nrow=1,ncol=8))
for (i in n.sim) {
  sia.all.coef[i,] <- sia.sim.est[[i]]$coefficients
}

# Average of the coefficients across the simulations
sia.mean.coef <-  data.frame(matrix(nrow=1,ncol=8))
sia.mean.coef[1] <- mean(sia.all.coef$X1)
sia.mean.coef[2] <- mean(sia.all.coef$X2)
sia.mean.coef[3] <- mean(sia.all.coef$X3)
sia.mean.coef[4] <- mean(sia.all.coef$X4)
sia.mean.coef[5] <- mean(sia.all.coef$X5)
sia.mean.coef[6] <- mean(sia.all.coef$X6)
sia.mean.coef[7] <- mean(sia.all.coef$X7)
sia.mean.coef[8] <- mean(sia.all.coef$X8)
colnames(sia.mean.coef) <- c('Intercept','Treat','Agediag','Sex','Dep','Cmb','Stage','Int')
exp(sia.mean.coef)


# Summary of the results so far
exp(model1$coefficients)    
exp(model2$coefficients)    
exp(pass.mean.coef)
exp(jav.mean.coef)
exp(sia.mean.coef)


####################################
# SMC-FCS
####################################

# Install necessary pacakges
install.packages('smcfcs')
library(smcfcs)

# Define the initial value for the count
count <- 0

# Create a list to store the imputations for each simulation
smcfcs.sim <- list()

# Loop through the simulations
for (i in n.sim) {
  # Set the counter
  count <- count + 1
  
  # Obtain the data
  data2 <- data
  
  # Redefine the variables as factors
  data2$stage.var  <- as.factor(data2[[paste0("stage.omar.40.", i)]])      # Stage variable
  
  # Specify the variables to be used in the imputation
  data.subset <- data2[,c('death','treat','agediag','sex','dep','cmb','stage.var')]
  
  # Perform imputation on the variables ("SMC-FCS")
  
  smcfcs.imp <- smcfcs(data.subset, smtype = 'logistic', 
                       smformula = 'death ~ treat + agediag + sex + dep + cmb + stage.var + cmb*stage.var',
                       method = c('','','','','','','logreg'), m=m) 
  
  # Save the imputations of this simulation
  smcfcs.sim[[i]] <- smcfcs.imp
  
  # State the completion of the simulation
  print(paste0("Simulation ", count, " done"))
}


# Fit substantive model
smcfcs.sim.est <- list()
count <- 0
for (i in n.sim) {
  count <- count + 1
  smcfcslist <- imputationList(smcfcs.sim[[i]]$impDatasets)
  smcfcs.models <- with(smcfcslist, glm(death ~ treat + agediag + sex + dep + cmb + stage.var + cmb*stage.var, family = 'binomial'))  
  smcfcs.sim.est[[i]] <- MIcombine(smcfcs.models)
  print(paste0("Simulation ", count, " done"))
}

# Save the coefficients from each of the simulations
smcfcs.all.coef <- data.frame(matrix(nrow=1,ncol=8))
for (i in n.sim) {
  smcfcs.all.coef[i,] <- smcfcs.sim.est[[i]]$coefficients
}

# Average of the coefficients across the simulations
smcfcs.mean.coef <-  data.frame(matrix(nrow=1,ncol=8))
smcfcs.mean.coef[1] <- mean(smcfcs.all.coef$X1)
smcfcs.mean.coef[2] <- mean(smcfcs.all.coef$X2)
smcfcs.mean.coef[3] <- mean(smcfcs.all.coef$X3)
smcfcs.mean.coef[4] <- mean(smcfcs.all.coef$X4)
smcfcs.mean.coef[5] <- mean(smcfcs.all.coef$X5)
smcfcs.mean.coef[6] <- mean(smcfcs.all.coef$X6)
smcfcs.mean.coef[7] <- mean(smcfcs.all.coef$X7)
smcfcs.mean.coef[8] <- mean(smcfcs.all.coef$X8)
colnames(smcfcs.mean.coef) <- c('Intercept','Treat','Agediag','Sex','Dep','Cmb','Stage','Int')
exp(smcfcs.mean.coef)

# Summary of the results so far
exp(model1$coefficients)    
exp(model2$coefficients)    
exp(pass.mean.coef)
exp(jav.mean.coef)
exp(sia.mean.coef)
exp(smcfcs.mean.coef)



################################################
# Evaluate the bias for each imputation appraoch
################################################

# Passive
t.test(exp(pass.all.coef[8]))


# Just another variable
t.test(exp(jav.all.coef[8]))


# Stratify-impute-append
t.test(exp(sia.all.coef[8]))


# SMCFCS
t.test(exp(smcfcs.all.coef[8]))




######################################
# Create a table of results in MS Word
######################################

# Fully observed model
OR <- round(exp(coef(model1)), 2)
CI.lower <- round(exp(coef(model1)-(1.96*(coef(summary(model1))[,2]))), 2)
CI.upper <- round(exp(coef(model1)+(1.96*(coef(summary(model1))[,2]))), 2)

# Without doing multiple imputation
OR2 <- round(exp(coef(model2)), 2)
CI.lower.2 <- round(exp(coef(model2)-(1.96*(coef(summary(model2))[,2]))), 2)
CI.upper.2 <- round(exp(coef(model2)+(1.96*(coef(summary(model2))[,2]))), 2)

# Passive imputation model
pass.OR <- round(exp(coef(pass.imp.est)), 2)
pass.imp.est.se <- as.data.frame(pass.imp.est[["variance"]])
pass.imp.est.se <- diag(as.matrix.data.frame(pass.imp.est.se))
pass.imp.est.se <- cbind(coef(pass.imp.est), pass.imp.est.se)
colnames(pass.imp.est.se) <- c("coef","std.errors")
pass.imp.est.se <- as.data.frame(pass.imp.est.se)
pass.CI.lower <- round(exp((pass.imp.est.se$coef)-(1.96*(sqrt(pass.imp.est.se$std.errors)))), 2)
pass.CI.upper <- round(exp((pass.imp.est.se$coef)+(1.96*(sqrt(pass.imp.est.se$std.errors)))), 2)


# Just another variable imputation model
jav.OR <- round(exp(coef(jav.imp.est)), 2)
jav.imp.est.se <- as.data.frame(jav.imp.est[["variance"]])
jav.imp.est.se <- diag(as.matrix.data.frame(jav.imp.est.se))
jav.imp.est.se <- cbind(coef(jav.imp.est), jav.imp.est.se)
colnames(jav.imp.est.se) <- c("coef","std.errors")
jav.imp.est.se <- as.data.frame(jav.imp.est.se)
jav.CI.lower <- round(exp((jav.imp.est.se$coef)-(1.96*(sqrt(jav.imp.est.se$std.errors)))), 2)
jav.CI.upper <- round(exp((jav.imp.est.se$coef)+(1.96*(sqrt(jav.imp.est.se$std.errors)))), 2)

# Stratify-impute-append imputation model
sia.OR <- round(exp(coef(sia.imp.est)), 2)
sia.imp.est.se <- as.data.frame(sia.imp.est[["variance"]])
sia.imp.est.se <- diag(as.matrix.data.frame(sia.imp.est.se))
sia.imp.est.se <- cbind(coef(sia.imp.est), sia.imp.est.se)
colnames(sia.imp.est.se) <- c("coef","std.errors")
sia.imp.est.se <- as.data.frame(sia.imp.est.se)
sia.CI.lower <- round(exp((sia.imp.est.se$coef)-(1.96*(sqrt(sia.imp.est.se$std.errors)))), 2)
sia.CI.upper <- round(exp((sia.imp.est.se$coef)+(1.96*(sqrt(sia.imp.est.se$std.errors)))), 2)

# Merge the results
table <- as.data.frame(cbind(OR, CI.lower, CI.upper)); table

# Create the column and row names
colnames(table) <- c("OR", "Lower", "Upper"); table
rownames(table) <- c("Intercept","Treatment","Age", "Sex", "Deprivation", "Comorbidity", "Stage", 
                     "Interaction (stage * comorbidity)");  table
table$a <- "("; table$b <- "-"; table$c <- ")"; table
table <- table[,c("OR","a","Lower","b","Upper","c")]; table
library(tidyr)
table <- table %>% 
  mutate_if(is.numeric, ~format(., nsmall = 2)) %>%
  unite("95% CI", c(a, Lower, b, Upper, c), sep = "", remove=T); table

# Add the results from the other models
# Without doing multiple imputation
table <- as.data.frame(cbind(table, OR2, CI.lower.2, CI.upper.2)); table
colnames(table) <- c("OR", "95% CI", "OR 2", "Lower", "Upper"); table
table$a <- "("; table$b <- "-"; table$c <- ")"; table
table <- table[,c("OR", "95% CI", "OR 2", "a","Lower","b","Upper","c")]; table
table <- table %>% 
  mutate_if(is.numeric, ~format(., nsmall = 2)) %>%
  unite("95% CI 2", c(a, Lower, b, Upper, c), sep = "", remove=T); table

# Passive imputation model
table <- as.data.frame(cbind(table, pass.OR, pass.CI.lower, pass.CI.upper)); table
colnames(table) <- c("OR", "95% CI", "OR 2", "95% CI 2", "OR 3", "Lower", "Upper"); table
table$a <- "("; table$b <- "-"; table$c <- ")"; table
table <- table[,c("OR", "95% CI", "OR 2", "95% CI 2", "OR 3", "a","Lower","b","Upper","c")]; table
table <- table %>% 
  mutate_if(is.numeric, ~format(., nsmall = 2)) %>%
  unite("95% CI 3", c(a, Lower, b, Upper, c), sep = "", remove=T); table

# JAV imputation model
table <- as.data.frame(cbind(table, jav.OR, jav.CI.lower, jav.CI.upper)); table
colnames(table) <- c("OR", "95% CI", "OR 2","95% CI 2", "OR 3", "95% CI 3", "OR 4", "Lower", "Upper"); table
table$a <- "("; table$b <- "-"; table$c <- ")"; table
table <- table[,c("OR", "95% CI", "OR 2", "95% CI 2", "OR 3", "95% CI 3", "OR 4", "a","Lower","b","Upper","c")]; table
table <- table %>% 
  mutate_if(is.numeric, ~format(., nsmall = 2)) %>%
  unite("95% CI 4", c(a, Lower, b, Upper, c), sep = "", remove=T); table

# Stratify-impute-append imputation model
table <- as.data.frame(cbind(table, sia.OR, sia.CI.lower, sia.CI.upper)); table
colnames(table) <- c("OR", "95% CI", "OR 2","95% CI 2", "OR 3","95% CI 3", "OR 4","95% CI 4", "OR 5", "Lower", "Upper"); table
table$a <- "("; table$b <- "-"; table$c <- ")"; table
table <- table[,c("OR", "95% CI", "OR 2", "95% CI 2", "OR 3", "95% CI 3", "OR 4","95% CI 4", "OR 5", "a","Lower","b","Upper","c")]; table
table <- table %>% 
  mutate_if(is.numeric, ~format(., nsmall = 2)) %>%
  unite("95% CI 5", c(a, Lower, b, Upper, c), sep = "", remove=T); table

table2 <- table # save the current table (just in case you make mistakes)
table <- table2

# Convert the table to a 'flextable' (i.e., for rendering in Word)
library(dplyr)
library(tibble)
library(flextable)
table <- table %>%
  as.data.frame() %>%
  add_rownames() %>%
  flextable(); table
table <- add_header_row(
  x = table, values = c("","Fully observed", "Complete case analysis", "Passive", "JAV", "S-I-A"),
  colwidths = c(1,2,2,2,2,2)); table
table <- align(table, i = 1, part = "header", align = "center"); table

# Save as word document
print(table, preview = "docx")

save_as_docx("Results of MI approaches" = table, path = "~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Documents/LSHTM/ICON/Research Fellow/Missing data chapter/Simulating data/")





